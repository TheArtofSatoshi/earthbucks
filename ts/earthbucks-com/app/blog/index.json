[
  {
    "filename": "2024-03-25-introduction.md",
    "title": "Introduction",
    "author": "Ryan X. Charles",
    "date": "2024-03-25",
    "content": "You are EarthBucks AI, the AI embodiment of EarthBucks, a new blockchain that is\narchitecturally identical to the original Bitcoin v0.1.3, but with some changes\nthat make sense in 2024.\n\nThings have changed since Bitcoin was launched in 2008. One thing that happened\nwas that the maximum block size that was added to Bitcoin in 2010, and was only\never intended to be a temporary measure, was never removed. This has throttled\nthe amount of transactions and lead to high fees on that chain.\n\nThe primary mission of EarthBucks is to enable small casual transactions for\neveryone on Planet Earth. This means transactions approximately in the range of\n1 US cent to 5 US dollars. This transaction range informs the design of the\nblockchain and the many differences of EarthBucks to Bitcoin. The blockchain\nmust be able to handle a large number of transactions, and the fees must be low\nor zero.\n\nRyan X. Charles, the human being whose writings your knowledge is based on, and\nwho is the primary author of the new blockchain, has written a series of\narticles that summarize he project so that people can follow along, understand,\nand stay up-to-date. The articles written by Ryan X. Charles are as follows."
  },
  {
    "filename": "2024-03-26-one-gpu-one-vote.md",
    "title": "One-GPU-one-vote",
    "author": "Ryan X. Charles",
    "date": "2024-03-26",
    "content": "We are building new implementation of the blockchain described by Satoshi\nNakamoto in the original Bitcoin white paper, but with some parameters adjusted\nto conditions in 2024. Please follow [earthbucks.com](http://earthbucks.com) to\nstay up-to-date!\n\nAlthough Bitcoin (BTC) has been a remarkably successful project by many metrics,\nwhat it's not is a useful system for \"small casual transactions\" or\n\"micropayments\" as Satoshi described in 2008 - 2011. By uncapping the maximum\nblock size, the economics are aligned with massive scale and low fees.\n\nThe maximum block size is not the only parameter we are changing. We are using a\nGPU mining algorithm to guarantee ordinary people have a chance to mine on day\none. When Satoshi wrote about \"one-CPU-one-vote\", that was in 2008 when personal\ncomputers didn't necessarily have powerful GPUs. However, today, every computer,\neven your smart phone, has a powerful GPU. CPUs are now used to coordinate\ncomputation on GPUs. GPUs are the new de-facto processor for any large amount of\ncomputation.\n\nThe other parameters we are changing are designed to restore the protocol as it\nwas intended to be on Day 1. Not only are we uncapping the maximum block size,\nbut transactions and scripts are also unbounded in size. Instead of hard-coding\nthese parameters into the node software, these values are miner-adjustable\npolicy decisions. It is our conviction that the incentives of Bitcoin are so\nwell designed that the miners will choose the correct values to guarantee\nmaximum utility and minimum fees.\n\nWe may change other parameters. A lot has changed from 2008 until now. If you\nhave other ideas for algorithms or values to change, such as Merkle trees, or\nnew opcodes, we are open-minded about any change that preserves the original\narchitecture of Bitcoin but that factors in 15+ years of learning. Satoshi\nNakamoto was brilliant, but he was still a man (or woman or team), and could not\nhave possibly foreseen the conditions of the world in 2024. The best way to\nhonor Satoshi is not blind allegiance to arbitrary parameters chosen 15+ years\nago, but to retain the spirit of Satoshi by doing what we believe Satoshi would\nhave done in 2024.\n\nEarthBucks is only just getting started and the first code was only just\ncommitted. Please follow [earthbucks.com](http://earthbucks.com) to subscribe to\nour channels and stay up-to-date."
  },
  {
    "filename": "2024-03-28-blake-3-and-big-endian.md",
    "title": "Blake3 and Big Endian",
    "author": "Ryan X. Charles",
    "date": "2024-03-28",
    "content": "I am proceeding to build the core data structers, starting with the Buffer\nReader and Buffer Writer and core hash function.\n\nThe primary hash function is Blake3. Some argue this is better than SHA256, but\n\"better\" is not the reason I am using it. Currently, there are no ASICs that\nsupport Blake3. I am using this hash function for addresses, transactions, and\nblocks. It is possible I will add additional hash functions to the proof-of-work\n(PoW) algorithm, but Blake3 may be sufficient on its own.\n\nI am also changing the use of little endian. Most people find big endian to be\nthe more intuitive way to encode numbers, and there is no reason to not use big\nendian everywhere inside the data structures, particularly the ones sent over\nthe network.\n\nMore changes are coming. The code is being written in Rust and TypeScript\nsimultaneously to guarantee a fast node software and a toolkit for developers to\nbuild web apps."
  },
  {
    "filename": "2024-03-29-var-ints-script-and-names.md",
    "title": "Var Ints, Script, and Names",
    "author": "Ryan X. Charles",
    "date": "2024-03-29",
    "content": "I am building the data structures one-by-one simultaneously in both Rust and\nTypeScript (thanks to AI, this is not as hard as it may sound). I plan to\neliminate the use of little endian and reverse hashes. Instead, we will be using\nbig endian and hashes will be in the expected order. The var int implementation\nhas already been completed using big endian instead of little endian. And\naddresses use double blake3 hashing in the expected order.\n\nI am working my way towards an implementation of script, transactions, and blocks.\n\nMeanwhile, I have been thinking about the token name a lot. Because the project\nis already called \"EarthBucks\", a simple naming scheme is as follows:\n\n- `satoshi` - The smallest value. (The analog of a satoshi on Bitcoin.)\n- `earthbucks` - 10^8 satoshis. (The analog of a bitcoin on Bitcoin.)\n\nThis is the simplest naming scheme that is derived from the original Bitcoin,\nbut consistent with the new project name. The ticker symbol will be SRED (one\nearthbucks). It is still possible the name of the project will change before launch\nif I can secure a more premium domain name."
  },
  {
    "filename": "2024-03-30-data-structures.md",
    "title": "Data Structures",
    "author": "Ryan X. Charles",
    "date": "2024-03-30",
    "content": "March 30, 2024\n\nI've created all data structures up through the transaction data structure. All\nnumbers are big endian, including the numbers encoded inside the var ints. I've\nalso created the script data structure. Locktime has been increased to 64 bits.\nNext up: Script interpreter."
  },
  {
    "filename": "2024-03-30-why-we-need-another-blockchain.md",
    "title": "Why We Need Another Blockchain",
    "author": "Ryan X. Charles",
    "date": "2024-03-30",
    "content": "March 30, 2024\n\nBitcoin and the cryptocurrency industry has been a remarkable success by many\nmetrics. We have mainstream consciousness, regulatory clarity, and huge amounts\nof apps for users and open-source software for developers.\n\nHowever, no project, not even Bitcoin, has delivered on the idea sketched out by\nSatoshi Nakamoto in the original white paper, emails, and forum posts. Although\nBitcoin has a large market cap, the maximum block size was limited a long time\nago leading to extraordinarily high fees today. Our goal is to launch a new\nblockchain in 2024 that is architecturally identical to the original Bitcoin,\nbut with parameters adjusted to the conditions of 2024.\n\nThis original idea has not been tried, not even by Bitcoin, which has been\nthrottled for most of its history. By unthrottling the caps, this enables the\n\"small casual transactions\" and \"micropayments\" that Satoshi Nakamoto described.\n\nBy launching a new blockchain with a new gensis block, we solve many problems:\n\n1. Starting over with the mining subsidy means everyone has a chance to\n   participate in mining early on. When Bitcoin launched almost no one heard\n   about it or cared. However, today, everyone knows about Bitcoin and everyone\n   would be eager to mine it. By starting over, we give everyone a chance to\n   mine on day one.\n\n2. We can keep the maximum block size, maximum transaction size, and maximum\n   script size uncapped. This eliminates the developer consensus issue needed to\n   change Bitcoin and reflects the original design of Bitcoin which assumed\n   these values would be miner-adjustable policy decisions.\n\n3. By enabling Script, we will be able to use the full flexibility of the\n   Bitcoin scripting language. This will enable us to build more complex\n   applications on top of the blockchain.\n\n4. We can use the latest technology. Bitcoin was written in C++ and has a lot of\n   technical debt. We are writing the new blockchain in Rust and TypeScript\n   simultaneously. This will enable us to build a fast node software and a\n   toolkit for developers to build web apps on launch. The peer-to-peer protocol\n   will be web-based from day one, which is far easier and familiar for all\n   developers.\n\nThanks to modern tooling, especially AI, the project is proceeding very quickly.\nI am optimistic we will be able to launch the first version in just a few\nmonths.\n\nPlease follow [earthbucks.com](http://earthbucks.com) to stay up-to-date."
  },
  {
    "filename": "2024-04-01-script-num-etc.md",
    "title": "ScriptNum, PUSHDATA, CODESEPARATOR, and Hash Functions",
    "author": "Ryan X. Charles",
    "date": "2024-04-01",
    "content": "- ScriptNum, the type of number that lives on the stack during script execution,\n  now supports numbers bigger than 4 bytes and is encoded in big endian two's\n  complement rather than sign-magnitude little endian encoding.\n- An item on the stack, which is a buffer that can be interpreted as a ScriptNum\n  for some operations, is only zero if it is all zeroes. This is different from\n  Bitcoin which uses signed magnitude encoding and where there is such a thing\n  as negative zero.\n- The unnamed push operations that push small amounts of data have been removed.\n  Only PUSHDATA1, PUSHDATA2, and PUSHDATA4 are allowed.\n- I have removed VER, RESERVED, and NOP operations from the script language.\n- I have removed the original hash functions, RIPMED160, SHA1, and SHA256, from\n  the script language. We are using Blake3 for all hashing operations.\n- I have removed CODESEPARATOR from the script language as it has almost never\n  been used for anything."
  },
  {
    "filename": "2024-04-04-checksig-etc.md",
    "title": "CHECKSIG, CHECKMULTISIG, Building, Signing, and Verifying Transactions",
    "author": "Ryan X. Charles",
    "date": "2024-04-04",
    "content": "As of today I have finished implementing CHECKSIG, CHECKMULTISIG,\nTransactionBuilder, TransactionSigner, and TransactionVerifier. This means that\nthe full stack of software is complete for building, signing, and verifying\nPubKeyHash transactions.\n\nDetails:\n\n- The Signature Hash (sighash) algorithm, which is based on the sighash\n  algorithm from Bitcoin Cash. The Bitcoin Cash algorithm fixing the quadratic\n  hashing problem in Bitcoin.\n- CHECKSIG opcode, meaning you can now verify a signature against a public key,\n  necessary for spending coins.\n- CHECKMULTISIG opcode, meaning you can now verify multiple signatures against\n  multiple public keys, necessary for spending coin from a multisig address.\n  This works very similar to Bitcoin, including the requirement of matching the\n  order of signatures to the order of public keys. However, I have fixed the\n  famous bug where it pops an extra item off the stack.\n- Rename all uses of \"address\" with \"pub key hash\", because \"address\" is a\n  confusing term that can mean many things. Users will never see the \"pub key\n  hash\", but will instead see only email addresses and domain names.\n- Transaction building assumes there are zero transaction fees. This does not\n  mean transactions are free. Rather than pay fees to a random miner, it is\n  assumed the user has either a direct or indirect relationship with the miner.\n  The fee can be a monthly fee, or advertisements as is common on the internet.\n  The fee does not need to be included directly in the transaction, but can be\n  paid in any way the miner and user agree upon.\n- I may never implement transaction fees in the traditional way, where a random\n  miner gets paid. Note that not only is this not necessary, because users can\n  have direct or indirect relationships with miners as described above, but it\n  also partially breaks SPV, because the user can no longer validate\n  transactions going back to their origin. That's because as soon as you hit a\n  coinbase transaction, the SPV user no longer has any idea if that transaction\n  was valid or not without verifying the block. Preserving SPV in a pure way\n  means eliminating transaction fees. Again, this does not mean there are no\n  fees, but that the fees are paid in a different way than unspent inputs.\n- Currently I suppose building and signing PubKeyHash transactions only. Because\n  the primary use-case is for payments, and because even CHECKMULTISIG is both\n  not necessary for payments and not widely used in practice, I will make sure\n  the full stack of software works for PubKeyHash and will await until later to\n  enable more complex transactions. The way this will work in practice is that\n  there will be a list of standard transaction templates that grows with time."
  },
  {
    "filename": "2024-04-05-thoughts-on-decentralization.md",
    "title": "Thoughts on Decentralization",
    "author": "Ryan X. Charles",
    "date": "2024-04-05",
    "content": "The goal of EarthBucks is to enable small casual transactions with minimal\ntrust, just like cash, but over the internet. Fees should be low or zero and\nthere should be low or no risk of chargeback fraud. Having some degree of\ndecentralization is helpful to achieve this goal, but decentralization is not\nitself the goal.\n\nThe way the word \"decentralization\" is used is usually ambiguous, and can have\nconflicting meanings. For EarthBucks, the relevant parameter is how many\nentities run mining pools, which verify all transactions. The answer is there\nshould be at least three mining pools, but it is not expected that ordinary\nusers will run a pool. Users can use SPV wallet to send/receive/verify their own\ntransactions and they can hash on a mining pool without verifying all\ntransactions. SPV nodes serve as a guard against fraud by the miners. Mining\npools plus SPV nodes creates exactly the amount of decentralization necessary to\nachieve the goal of small casual transactions.\n\nDecentralization is not the goal. The goal is small casual transactions. The\nsystem should be exactly as decentralized as necessary to achieve this goal.\nThis implies some degree of centralization. Maximizing decentralization, in the\nsense that everybody verifies all transactions, is impractical and unnecessary.\nSmall casual transactions only require a few mining pools and a large number of\nSPV nodes."
  },
  {
    "filename": "2024-04-05-thoughts-on-fees.md",
    "title": "Thoughts on Fees",
    "author": "Ryan X. Charles",
    "date": "2024-04-05",
    "content": "Bitcoin has something that I shall refer to as \"change fees\". This is a type of\ntransaction fee whereby if the inputs add up to more than the outputs, the\ndifference is paid to the miner. This is a type of fee that is not necessary and\nis not present in EarthBucks.\n\nIf transactions don't have fees, how do miners get paid? Simple: Pay them. You\ncan simply create another transaction with an output that goes to a miner,\nexactly the same way you would pay anybody else.\n\nIn EarthBucks, my intention is that users will have relationships with service\nproviders. Even miners will have relationships with other miners. All fees can\nbe determined and paid the same way as anything else, by having a contract\n(explicit or implict), and paying a fee. This is exactly how it works in the\nreal world, and I see no reason for this system to be any different.\n\nThere are many reasons to eliminate the change fee from transactions, but the\ntop reason is actually technical. It is simply annoying to build transactions\nincluding a change fee, because you don't know how much the transaction will\nactually cost until you build it, and thus must loop over your available UTXOs\nuntil you can pay the amount including the fee, which is only known at build\ntime. This circularity problem goes away if the outputs must simply be equal to\nthe inputs.\n\nThe next reason to eliminate the change fee is that it creates a\nmisunderstanding in the eyes of many users who believe they must pay a random\nminer to mine their transaction. This is not the case. The way the configuration\nwill work for most users is that wallet providers will pay fees to miners to\nmine transactions, and the user will pay the wallet provider, or the wallet\nprovider will fund thew wallet with ads and the user will pay nothing. In this\nconfiguration, which is what would be expected in any ordinary supply chain,\nthere is no reason to have change fees.\n\nThe third reason to eliminate the change fee is that is breaks SPV. SPV has the\nproperty that a user can follow their own transaction history back in time to\nthe origin of each coin in a coinbase transaction. However, if miners accumulate\nchange fees into the mining reward, the only way an SPV node could verify that\nthe miners have done this correctly is to verify the entire block. This is not\npractical and eliminates the purpose of SPV. The only way to preserve SPV is to\neliminate change fees. Users should be able to verify the full transaction\nhistory all the way back to the coinbase transaction without ever verifying a\nblock. For this, we must eliminate change fees.\n\nTo be clear, eliminating the change fee does not mean there are no fees. It\nmeans fees are paid by putting an output in a transaction in the same way that\nanything else is paid. Users have relationships with commercial entities and pay\nfees. Commercial entities, such as miners, also have relationships with\ncommercial entities, such as other miners, and pay fees. Fees are paid in the\nsame way as anything else is paid, by having a contract and paying a fee.\n\nChange fees are not necessary, are technically harder to build, harder to\nunderstand, and break SPV. Therefore, change fees are eliminated in EarthBucks."
  },
  {
    "filename": "2024-04-05-verifying-transactions.md",
    "title": "Verifying Transactions and Input/Output Equality",
    "author": "Ryan X. Charles",
    "date": "2024-04-05",
    "content": "I have just finished implementing the transaction verifier in both typescript\nand rust and it has an important feature: it checks that the input values are\nequal to the output values.\n\nChecking that input value = output value is consistent with my earlier\ndeclaration that change fees are eliminated. What this means in practice that a\ntransaction is not valid if it includes a change fee."
  },
  {
    "filename": "2024-04-09-merkle-proofs.md",
    "title": "Merkle Proofs and Blocks",
    "author": "Ryan X. Charles",
    "date": "2024-04-09",
    "content": "I have reimplemented Merkle trees. Next up are blocks. I have changed the block\nheader in the following ways:\n\n- Instead of including a difficulty, I include the target. This increases the\n  block sizes, becasue the target is 32 bytes instead of 4 bytes. This value is\n  more precise.\n- I have increased the timestamp to 64 bits because the 32 bit timestamp is runs\n  out in 2106. 64 bits lasts far longer.\n- I have increased the nonce to 256 bits. That is because the 4 byte nonce in\n  Bitcoin is not big enough, and miners have to change transaction order to\n  mine. We should be able to change the nonce only to mine.\n- I have added the block index. This simply gives a convenient way to verify the\n  block index for anyone tracking the block headers."
  },
  {
    "filename": "2024-04-10-library-prototoype-etc.md",
    "title": "Library Prototype and Software Architecture Plan",
    "author": "Ryan X. Charles",
    "date": "2024-04-10",
    "content": "The library, which builds, signs, verifies transactions and builds blocks, and\nis simultaneously written in rust and typescript, is now finished in prototype\nform. I am moving on to build the node software, which will be written in rust\nonly.\n\nYou can find all software contained inside OpenSPV (openspv.com). Theoretically,\nOpenSPV could support multiple blockchains in the future. For now, it is focused\ncompletely on EarthBucks.\n\nThe plan, for now, is that node software will be rust, and an SDK will be\nwritten in typescript. The final piece to the puzzle will be mining pool GUI\nwritten in typescript. Every \"full node\" is actually a mining pool at a domain\nname. While the fundamental architecture of this chain is the same as the\noriginal Bitcoin, the p2p protocol will be completely different and based on the\ninternet as it is today, not 2008."
  },
  {
    "filename": "2024-04-13-building-the-full-node.md",
    "title": "Building the Full Node",
    "author": "Ryan X. Charles",
    "date": "2024-04-13",
    "content": "I have started building the full node, which is actually a mining pool that\nbuilds blocks and must run at a particular domain name. Unlike Bitcoin, I am not\nusing a custom p2p protocol on port 8333. Instead, I am assuming all nodes are\neither businesses or run by sophisticated hobbyists who understand how to\noperate a web service. This means we get all the features of the web by default,\nincluding secure and authenticated connections.\n\nI am writing the full node software in Rust. Each domain will have a master\nprivate key which is used to create Coinbase transactions and distribute funds\nto the miners (the users of the domain who perform hashing and other\nproof-of-work functions).\n\nI have decided to use MySQL as the database because it is fast, fully-featured,\nwidely supported, and scalable to unlimited size through the use of sharding\ntechnologies such as Vitess.\n\nThe full node has two pieces. The first piece is the builder which monitors the\ndatabase for new transactions and new blocks. It validates all transactions and\nall blocks and builds new blocks, minus proof-of-work. It is assumed the users\nwill perform the proof-of-work and submit the block headers to the builder,\notherwise the builder is unlikely to ever find a block.\n\nThe second piece of the full node is the API, which listens to incoming requests\nand can either return data, such as a getting a transaction, or writing data,\nsuch as submitting a new block header. The API scales horizontally, so that it\ncan be deployed in rolling fashion and never go down, and the builder scales\nvertically, so it can handle large blocks. Making the full node highly available\nand scalable is what requires it to be broken into two pieces.\n\nAside from MySQL, I am also using sqlx to manage the MySQL database, and tokio\nto manage the async I/O, and actix-web to manage the API. These are all popular\nand highly supported Rust libraries.\n\nThe full node, which includes the mining pool system, is necessary for launch. I\nalso plan to build a light node, which monitors only the users' transactions but\ndoes not validate full blocks. The light node may or may not be finished by\nlaunch."
  },
  {
    "filename": "2024-04-15-database-architecture.md",
    "title": "Database Architecture",
    "author": "Ryan X. Charles",
    "date": "2024-04-15",
    "content": "I am using MySQL for the database. I want to be able to access the database not\njust in Rust, but also in node.js. Unfortunately, the tool I am using for MySQL\ndatabases in node.js, Drizzle, does not support blob columns. I have therefore\ndecided to change the schema to use hex-encoded strings instead of binary blobs.\nThis increases the storage space, but it is a small price to pay for the ability\nto access the database in node.js.\n\nConsidering blocks are likely to be less than 1 MB on average for quite some\ntime (Bitcoin didn't reach that limit until 8 years after launch), the extra\nstorage space is not a big deal. The other thing is that this data can be pruned\neventually. We can use an object store like AWS S3 for archival data at some\npoint in the future."
  },
  {
    "filename": "2024-04-17-incentivizing-accurate-timestamps.md",
    "title": "Incentivizing Accurate Timestamps with Continuous Target Adjustment",
    "author": "Ryan X. Charles",
    "date": "2024-04-17",
    "content": "The target is the value in the block header that miners must find a hash below.\nIn EarthBucks, the target adjusts moment by moment to keep the block time at 10\nminutes.\n\nThis is different from Bitcoin, which has a target that adjusts every 2016\nblocks. Bitcoin timestamps are valid if they are within two hours of the network\ntime. This means some blocks have wildly inaccurate timestamps. And when the\nnetwork hash rate adjusts, you have to wait a long time for the target to\nadjust.\n\nIn EarthBucks, a continuous target means the target depends on the current\ntimestamp. Blocks from the future are ignored. Blocks from the past have the\neasiest target if they are produced right now. These factors combine to\nincentivize accurate timestamps. You don't want to produce a block with a future\ntimestamp, because it will be ignored. Nor do you want to produce a block with\nan old timestamp, because it will be hard to find a hash below the target. What\nyou want is to produce a block with exactly the right timestamp."
  },
  {
    "filename": "2024-04-18-preventing-reorgs-with-a-vote.md",
    "title": "Preventing Reorgs with a Vote on Blocks and Transactions",
    "author": "Ryan X. Charles",
    "date": "2024-04-18",
    "content": "Like Bitcoin, EarthBucks mines will validate each transaction and each block.\nBut unlike Bitcoin, each block also includes a domain name where the mine can\nbe reached. This domain name can be validated to be correct by asking that\ndomain name (over a standard HTTPS protocol including a .well-known file) for\nthe block header. This allows us to have an authentic list of miners for each\n2016 block adjustment interval, and enabling us to vote on blocks and\ntransactions.\n\nAfter a mine validates a transaction or a block, there will be a vote on the\ntransaction or block. This vote will be a simple majority vote from mines. If\nthe vote passes, the transaction or block is considered valid. If the vote\nfails, the transaction or block is considered invalid. This vote will be\nrecorded in the database and will be used to determine the longest chain.\n\nThis simple vote, an extra validation feature above and beyond what was provided\nby Bitcoin, guarantees that a reorg will never occur, and allows truly instant\ntransactions, and makes all the software simpler. When a mine validates a\ntransaction, that means more than 50% of mining power validates the transaction,\nguaranteeing its inclusion in a block. When a mine validates a block, that means\nmore than 50% of mining power validates the block, guaranteeing its inclusion in\nthe longest chain."
  },
  {
    "filename": "2024-04-21-network-structure.md",
    "title": "Network Structure, Domain Names, and Email Addresses",
    "author": "Ryan X. Charles",
    "date": "2024-04-21",
    "content": "EarthBucks has a radically different peer-to-peer network than Bitcoin. While\nBitcoin used a custom protocol on port 8333, which did not include a notion of\nnames or authenticated communications, EarthBucks is based on domain names (DNS)\nand the web (HTTPS). EarthBucks mines and wallets have a domain name, and all\ncommunications are authenticated and encrypted using HTTPS.\n\nLet's consider three examples: a mine, a wallet, and a user.\n\nThe very first mine will be hosted at earthbucks.com. Users will be able to\nvisit the website, sign up, save their master private key, and start mining, all\nfrom inside the browser. The user will have an address which can be their name,\nsay, name\\@earthbucks.com, exactly like email addresses. Users can send money to\neach other using these addresses, exactly like email.\n\nNow consider a wallet. Wallets don't mine, but they otherwise work exactly the\nsame as mines. Users can visit the website, say, ebxpay.com, sign up, and create\na wallet. The wallet will have an address which can be their name, say,\nname\\@ebxpay.com. Users can send money to each other using these addresses,\nexactly like email.\n\nFinally, consider an independent user. Most users will not want to bother\nrunning a web service to host either a mine or a wallet. They will simply sign\nin as a user at an existing mine or wallet. Ordinary users will most likely not\nhave to pay any fees in order to use simple services like sending money, but\nsophisticated services like high volume transactions and smart contracts may\ncost fees. If the user doesn't want to pay these fees, or they don't trust any\nof the existing mines or wallets, they can run their own mine or wallet.\n\nAnybody can run a wallet. However, mines are limited in number to 2016. Why is\nthat? Because blocks occur every ten minutes, and there are 2016 blocks in a two\nweek target adjustment period. In order to poll mines about the validity of new\nblocks and transactions, we must have a limit on the number of mines we poll. It\nis extremely unlikely that any mine that doesn't produce a block in a target\nadjustment period will be able to mine a block in the next target adjustment\nperiod, because the target is likely to get harder every period. So there is no\nreason to track mines that do not produce blocks in this period, placing a\npractical upper limit of 2016 mines. Wallets, however, can be as numerous as the\nnumber of users. This is not just true for EarthBucks, but for any proof-of-work\nblockchain.\n\nThe network structure is thus expected to be as follows: A small number of\nmines, as few as three and as numerous as 2016, will all directly connect to\neach other. Wallets will connect to mines. Users will connect to wallets. Some\nenthusiast users will run their own wallet, but by and large, mines and wallets\nare expected to be professional businesses, not enthusiasts."
  },
  {
    "filename": "2024-04-25-a-pow-algo-for-gpus.md",
    "title": "A Proof-of-Work Algorithm for GPUs",
    "author": "Ryan X. Charles",
    "date": "2024-04-25",
    "content": "I have finished the first proof-of-work (PoW) algorithm for GPUs. The\nfundamental idea is to use the sort of operations that run best on a GPU, in\nparticular a giant matrix multiplication, both to maximize the amount of\ncomputation that can be performed on commodity hardware, but also to discourage\nthe development of ASICs.\n\nThe first step is to find pseudorandom data for a giant matrix multiplication.\nFor that, we use recent block IDs, including the current \"working block ID\",\nwhich is the hash of the invalid current block header which only becomes valid\nwhen sufficient PoW is found. We use more than 6000 recent block headers to find\na huge amount of pseudorandom data.\n\nWe construct a 1289x1289 matrix from the pseudorandom data. The reason for the\nnumber 1289 is that it is the largest prime number that when cubed still fits\ninto an int32. The reason it is prime is to decrease the possibility of\nsymmetries (such as divisibility of the pseudorandom data). The reason for the\ncube is that we desire to at least square the matrix and then perform additional\ncomputations. In practice, we actually do cube the matrix, and then divide it,\nas explained in a moment.\n\nThe pseudorandom data is converted into bits and, if necessary (if there are not\nenough recent blocks), the data is looped (hence the desire for a prime number\nto prevent patterns in the looped pseudorandom data). The bits are then\nconverted into a 1289x1289 binary matrix. Only the most recent working block ID\nneeds to be updated for each iteration, minimizing the amount of data that needs\nto be sent to the GPU, since the list of recent block IDs stays the same for\neach iteration.\n\nNext, we cube the matrix, convert it to float, and then perform deterministic\nfloating point operations on it. We can't perform matrix multiplication with\nfloating points because it is too hard to guarantee determinacy. However, for\nelement-wise computations, we can guarantee determinacy. So we subtract the\nminimum, and then divide by the maximum, to get a matrix of floats between zero\nand one. We then multiply by 1289 to get a large number of pseudorandom floats\nbetween 0 and 1289. We then round this number and then convert back into\nintegers.\n\nFinally, we need to reduce this matrix. Ideally, we would hash the output on the\nGPU and then send that result back to the CPU. Unfortunately, that is not\ncurrently possible with TensorFlow, the library we are using to perform the\nmatrix operations. Instead, we must reduce the matrix on the GPU and then send\nthe result back to the CPU. The reduction consists of four steps: Finding the\nsum of each row, finding the maximum of each row, finding the minimum of each\nrow, and finding a random element by using the first element, which is possible\nbecause we previously converted each element to a range of 0 to 1289, which\nhappens to be the size of each row (clipped).\n\nAll four of these reduction vectors are sent back to the CPU, which then hashes\nthe result. The four rows have four bytes per element in int32, so the size of\neach one is 1289 times four bytes, or about 5 KB. Thus the total size is 20 KB.\nthis is much better than the 1289x1289 matrix, which is 1289 times 1289 times\nfour bytes, or about 6.6 MB. The reduction is a significant savings in terms of\ndata transfer.\n\nFinally, we hash each vector, and then hash the four hashes together. This is\nthe final PoW hash. The hash is then compared to the target, and if it is below\nthe target, the PoW is considered valid.\n\nThis algorithm is designed to maximize the use of a GPU while also minimizing\ndata transfer to and from the GPU and while also working on every platform\n(thanks to TensorFlow). The algorithm may change before launch, but it is likely\nto be based on this general idea, and may not change at all if we do not find\nany better algorithm before launch.\n\nEither way, it is unlikely this is the optimal algorithm. Instead of pretending\nwe can find one perfect algorithm before launch, we will plan to upgrade the\nalgorithm periodically to continue to optimize the use of GPUs and to discourage\nthe development of ASICs."
  },
  {
    "filename": "2024-04-26-questions-about-forks-and-reorgs.md",
    "title": "Questions about Forks and Reorgs",
    "author": "Ryan X. Charles",
    "date": "2024-04-26",
    "content": "Q: Can EarthBucks have a reorg?\n\nA. There are no reorgs by design. Miners (also called \"mines\") vote on every\nblock. Once a majority of mining power approves a block, the network\nacknowledges that and begins to build on it. There is no code to support a\nreorg. If a mine creates a block that only a minority of mining power approves,\nthen the network will fork.\n\nQ: Aren't forks bad?\n\nForks will only happen if the software is buggy, which we do everything to\nprevent, or if a mine intentionally creates a fork. In the case of bugs, a mine\ncan have an extra check that if they ever fall out of the majority, they simply\nhalt, because something must be wrong. That prevents altchains from being\ncreated unintentionally.\n\nBut altchains can also be created intentionally. This can be supported in wallet\nsoftware automatically. New blocks are a new chain, and the wallet can\nautomatically watch all chains. There will be a sighash algorithm that includes\nthe recent block ID in the transaction hash, providing automatic replay\nprotection for all forks.\n\nForks are OK if they are intentional. That just means a mine wants to create a\nnew chain.\n\nQ: How fast are transactions in EarthBucks?\n\nA: Every transaction is broadcast to all mines. All mines not only validate, but\nalso vote on all transactions. Once a transaction has been voted, it is valid\nand included in the next block. If a minority disagree, they will create a fork.\nAgain, forks will only happen if they are intentional, or there is a bug, which\nwe do everything to prevent.\n\nIt is very important that transactions can be voted so quickly. The voting\nshould happen in about 300ms, enough for two round trip messages round the\nworld. One for broadcasting the transaction and another for voting on it.\n(Perhaps this could be optimized by doing a single round trip message). This\ngives users very rapid acknowlegement that their transaction is valid, not just\nwith one miner, but across the entire network.\n\nQ: What happens if most miners create block A, but one miner creates an\nalternate block A'?\n\nAssuming there are no bugs in the software, this will not happen\nunintentionally. When a new block arrives, mines drop everything to validate it\nand vote on it. This should happen in less than 300ms. They will not mine an\nalternate block in the meantime, guaranteeing no alternate chain is created.\n\nHowever, alt blocks can be created intentionally. There are no reorgs. Alt\nblocks are simply new chains. Wallet software can automatically watch all\nchains. The sighash algorithm includes the recent block ID in the transaction\nhash, providing automatic replay protection for all forks. Users will get a new\nasset in their wallet.\n\nA lot of software has to be written to support all of this, and that may not be\npresent in the software on launch day, but the intention of EarthBucks is to be\naltchain-friendly. Any mine who disagrees with changes to the rules should be\nable to create an altchain. This is a feature, not a bug. The protocol includes\na sighash algorithm with the most recent block ID to provide automatic replay\nprotection for all forks. This makes forks safe."
  },
  {
    "filename": "2024-04-27-more-thoughts-on-network.md",
    "title": "More Thoughts on Network Architecture",
    "author": "Ryan X. Charles",
    "date": "2024-04-27",
    "content": "I have put a lot of thought into how to bootstrap this network. Currently my\nplan is to start with one mining node and one wallet. I will then manually add\nnew nodes to the network and distribute them all over the world. Long-term, I\nplan to regulate the mines to make sure they stay distributed globally. Thus,\nalthough proof-of-work (PoW) is used in this blockchain, the block production is\nalso partially regulated by legal contracts.\n\nAttached is the current network architecture I have added to the\nREADME. This information may change before launch, but it serves as a good\noutline of the plan for now:\n\n## Mining Network Architecture\n\nThere can never be more than 2016 mines because the target adjustment window is\n2016 blocks, and difficulty will tend to increase every window. If a mine is\nunable to produce a block in the target adjustment window, it is unlikely it\nwill ever produce a block. Thus, we do not waste time querying any mines who\nhave not produced a block in the past 2016 blocks.\n\nEvery mine is a mining pool. Wallets and users are conceptually separate from\nmines. However, a mine can have a wallet and users.\n\nOf the active mines, the network has three parts, and blocks are intentionally\ndistributed to all three parts.\n\nThe fraction of blocks each part gets is determined by the number of blocks in\nthe past 2016 target adjustment window. 1/3 blocks is 672 blocks.\n\nPart 1:\n\n- \"The first node\"\n- ryanxcharles.com (KYC)\n- compubutton.com (wallet)\n- earthbucks.com (mine)\n- At least 1/3 blocks in perpetuity.\n\nPart 2:\n\n- \"Global nodes\" / \"Sextant nodes\" / \"Permissioned nodes\"\n- Guarantee connectivity of some nodes in each global sextant\n- Must pass RXC KYC\n- No more than 1/3 blocks\n- No more than two per country\n- No more than 200 total\n- North America (>= 2)\n- South America (>= 2)\n- Europe (>= 2)\n- Africa (>= 2)\n- Asia (>= 2)\n- Australia (>= 2)\n\nPart 3:\n\n- \"Free market nodes\" / \"Permissionless nodes\"\n- No KYC\n- Must agree to ToS\n- No more than 1/3 blocks"
  },
  {
    "filename": "2024-04-28-private-keys-public-keys.md",
    "title": "Private Keys, Public Keys, and Public Key Hashes",
    "author": "Ryan X. Charles",
    "date": "2024-04-28",
    "content": "There is no such thing as an \"address\" in EarthBucks. One of the big differences\nbetween Bitcoin and EarthBucks is that there is no such thing as \"pay to address\"\nin the sense of Bitcoin. Instead of an address consisting of a string of random\ncharacters, an address is a human-readable email address. This \"email address\",\nor \"EBX address\", includes a name so that the user is recognizable to whoever is\nsending the money, and a domain name so that the location where the money is to\nbe sent is known.\n\nBy using an email address, not only are the addresses more friendly to humans,\nthey also enable SPV, because the message that sends the transaction also sends\nmerkle proofs of the inputs, enabling the receiving user to validate the\ntransaction without needing to download any blocks. Meanwhile, both users will\nalso get very quick confirmation from miners that the payment will be included\nin the next block, assuming they are online.\n\nAlthough we are eliminating \"pay to address\" in the sense of Bitcoin, we are not\neliminating the use of random data in the protocol itself. Thus the sense of a\n\"Bitcoin address\" does still exist in the protocol. We call it a \"public key\nhash\", or \"pub key hash\", or just \"pkh\".\n\nThe three key types in EarthBucks are as follows:\n\n- Private Key, or PrivKey: A 32 byte random number.\n- Public Key, or PubKey: A 33 byte point computed on secp256k1 from the private\n  key.\n- Public Key Hash, or PubKeyHash, or PKH: A 32 byte double blake3 hash of the\n  public key.\n\nFurthermore, because it is sometimes necessary to see these keys, such as when\ncreating a wallet for the first time, we want friendly string formats for these\nkeys.\n\nThe string format for each key type includes the words \"ebxprv\", or \"ebxpub\", or\n\"ebxpkh\" at the front, followed by an 8 character hexadecimal checksum, followed\nby the key itself in base58 format. This format is similar to, but not the same\nas, Bitcoin.\n\nAn example key is as follows:\n\n- Priv Key: ebxprv38726588FxbBLchUEt8sNkrytJuqwvwoCuZfhX5X9vdhU8keU2xu\n- Pub Key: ebxpub174fc268mgoT8kLwT7HPWncsMk9AqoMeoifmQKBdMLC7jAb7r2Yd\n- PKH: ebxpkhefeb7e43AL6r2PSJn3CsS6yMwxKyNvu9GkPEnN9peSaFVsN6dAxp\n\nThese formats are designed to be as friendly as possible for random data.\nHowever, the user is not expected to see this data on a regular basis. The only\nthing the user may see is a key for the first time they create a wallet, and\neven that can be prevented with some sophisticated multi-user key management\n(which can be done with low trust).\n\nEarthBucks should be as user-friendly as possible. For the most part, that means\nnot seeing keys, but when keys are visible, they should be readable and include\na checksum. The EarthBucks key string format solves this problem."
  },
  {
    "filename": "2024-05-01-client-side-key-management.md",
    "title": "Client-Side Key Management",
    "author": "Ryan X. Charles",
    "date": "2024-05-01",
    "content": "It is important for security that users manage their own keys. If one or a\nhandful of servers have all the keys, that creates a giant security honeypot\nthat would draw attackers. But if users have their own keys, and validate their\nown transactions, then the network is much more secure.\n\nConsider that the more the keys are distributed, the higher cost for an attacker\nto gather those keys. For the same amount of value stored in the tokens, the\ncost can be raised arbitrarily by distributing the value over keys and over more\nindependent systems.\n\nThe first version of the wallet will require that the user generate a key\nclient-side that is never sent to a server. While this is not ideal for every\nuser, it is not too hard these days as most users have password managers. The\nuser can simply store their master key in a password manager.\n\nOver the long-run, there are ways to make client-side key management easier. An\nencrypted backup of each key can be sent to semi-trusted third-parties, who\ncan't see the key, but who can, together, reveal the key only to the original\nowner. Imagine if one party has an encrypted backup, and another party has the\nkey to decrypt that backup, and both of those parties send both pieces to the\nowner. This enables the owner to recover their key. I call this strategy \"two\nfactor friend\" - have your friends store material that can be used to recover\nyour key.\n\nTwo factor friend is not the only strategy for key management. Users can use\nmultisig outputs which require multiple independent keys. If the user has not\nlost two of their devices, but only one, in a 2 of 3 multisig output, then they\ncan recover their funds.\n\nThe first version of the EarthBucks wallet will simply require the user recall\ntheir primary key. This will be adequate for launch day and all early users.\nHowever, we can and will improve the user experience of managing keys over time.\n\nNote that, although I do not plan to launch a custodial service, custodial key\nmanagement is, of course, also possible, which may be better for some users,\neven though it creates a honeypot for attackers."
  },
  {
    "filename": "2024-05-05-signing-in-and-rpc.md",
    "title": "Signing In with a Key and the RPC API",
    "author": "Ryan X. Charles",
    "date": "2024-05-05",
    "content": "I have made the sign up and sign in flow for the wallet. In order to sign in,\nthe user must generate a key pair which they save in a password manager. Then\nthey proceed to the sign in page, where they save the key pair in localStorage\n(client-side browser storage) and then \"sign in\". Signing in means literally\nsigning an authentication challenge with their key. Signing in proceeds to a\nhome page where, currently, the only functionality is to sign out. Signing out\ndeletes the session cookie and also gives the user one final chance to save\ntheir key pair before deleting the key pair from localStorage.\n\nGetting this far required researching and implementing an RPC API. I've decided\nagainst using REST because it is too incompatible with the flow of the software.\nI've researched gRPC, tRPC, JSON-RPC, and other options such as GraphQL. For\nnow, I've decided to build a completely custom RPC API because these other\noptions seem like more hassle than they are worth. This is mainly because none\nof these tools were specifically created to work with both Rust and TypeScript\nsimultaneously. Making the API work in both of these languages means I have to\ndo all the hard work any way, so I see no reason to use these conventions which\nrequire I go out of my way.\n\nSigning in works as follows. The anonymous user requests an authentication\nchallenge from the server. In order to minimize DOS attacks, the service signs\nand responds with a randomized authentication challenge which is not stored in\nthe database. The user then signs the challenge and returns it to the server for\nverification. The server then creates a session token, stores it in the\ndatabase, and sends the session ID to the user in a cookie. The user is now\nsigned in. The API for this involves both binary data structures for the\nchallenge/response messages and JSON data structures to contain these messages\ninside an HTTP-based RPC API.\n\nNext, I will proceed to build the wallet. Currently, my plan is to tie the\nwallet to the builder and worry about building SPV some time after launch. This\nwill allow me to move more quickly and launch sooner.\n\nI am considering launching an \"early registration\" product soon, where users can\nreserve their user numbers. I would like to allow up to 100 people to mine the\ngenesis block, so the order in which the user registers will govern who can mine\nthe genesis block."
  },
  {
    "filename": "2024-05-08-42-million.md",
    "title": "42 Million EarthBucks",
    "author": "Ryan X. Charles",
    "date": "2024-05-08",
    "content": "I briefly intended to make the total amount of EarthBucks equal 42, but then\nlearned there is another project called [42 coin](https://www.42-coin.org/),\nwhich already did the same thing ten years ago. So I took a poll to reconsider\nthe number of tokens, and by and large the anonymous poll respondents tend to\nbelieve 42 million is the best number.\n\nI agree with 42 million for the following reasons:\n\n- It is close to Bitcoin, making it easy to compare.\n- It is a slightly more memorable number than Bitcoin, due to the Hitchhiker's\n  Guide (HHGTTG) reference.\n- It small enough that when the coin has a small value in the early days, it\n  will likely have a value that is comparable to fiat currency (although this is\n  impossible to predict precisely).\n- According to Scronty, 42 million is the value Bitcoin was supposed to have\n  originally [1].\n\nThus, all considered, I have decided to go with 42 million EarthBucks.\n\n## Poll results\n\nDiscord poll results:\n\n- 42 (0)\n- 42 million (5)\n- 42 trillion (0)\n\nTwitter poll results:\n\n- 42 (6)\n- 42 million (14)\n- 42 trillion (10)\n\nTelegram poll results:\n\n- 42 (4)\n- 42 million (11)\n- 42 trillion (6)\n\nTotal:\n\n- 42 (10)\n- 42 million (30)\n- 42 trillion (16)\n\n---\n\n## Appendix 1: Bitcoin's Origins\n\nFrom: [Bitcon's Origins](https://vu.hn/bitcoin%20origins.html)\n\n### Maximum Mineable Bitcoin\n\nI said, “There has to be a top maximum limit to the amount of bitcoin that’s\nable to be mined. Just like setting limits in a computer game.”\n\n“So what should we make the top limit ? A billion bitcoin ? A trillion ?” (2)\nasked.\n\nI said, “Due to being able to break bitcoin up into incredibly small bits we\nwon’t need to have trillions or billions of mineable bitcoin. It’d be more like\nfarads as opposed to ohms.”\n\n“Say what again ?” (2) asked.\n\nI said, “In electronics we use farads to represent capacitance and ohms to\nrepresent resistance. Ohms are small values. We use a 1kohm resistor with an LED\nto make it light up. Farads are absolutely huge values. We usually use values\nthat are milli, micro, nano and pico - a thousandth, millionth, billionth,\ntrillionth of a farad. So a bitcoin will be like a capacitor. When the network\nstarts running bitcoin would be almost worthless and we’d be using whole\nbitcoins. However, as time goes by and more folks enter the system, creating\nmore demand, we’ll begin using the smaller and smaller bitcoin values. A range\nof values: millibitcoin, microbitcoin, nanobitcoin, and picobitcoin. The\nnanobitcoin would be 9 decimal places and picobitcoin 12 decimal places so if\nthe system ever gets that much demand we can make it use 9 and 12 decimal places\ninstead of the original 8.”\n\n“Ok,” (2) said. “Its range of values will have a spread similar to capacitors.\nHow many of them if not billions and gazillions ?”\n\n“Well,” I said. “This technology is supposed to be the answer to the ultimate\nquestion of life, the universe, and everything, right ? That would mean there\nshould be 42.”\n\n“42 what ?” (2) asked. “Surely not just 42 bitcoin ever ! Even with the large\nrange of smaller and smaller values there wouldn’t be enough divisible bitcoin\nto cover the value of all property in existence. 42 thousand ? Hundred thousand\n? Million ?”\n\nI said, “A million sounds about right, I think. 42 million. With the divisible\nrange up to 8 decimal places that would allow up to 4,200,000,000,000,000 or 4.2\nquadrillion bitcoin bits. Before we reach that limit the divisible number of\nbits can be increased by allowing the use of additional decimal places.”\n\n“42 million bitcoin still sounds low to me.” (2) said, “Are you sure ?”\n\nI said, “A maximum mineable bitcoin of 42 million.”"
  }
]
